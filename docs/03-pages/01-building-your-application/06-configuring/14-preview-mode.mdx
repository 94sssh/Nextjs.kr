---
title: 미리보기 모드 (레거시)
description: Next.js는 정적으로 생성된 페이지에 대한 미리보기 모드를 갖고 있습니다. 이곳에서는 미리보기 모드가 어떻게 작동하는지 배웁니다.
---

> **경고**: 이 기능은 **레거시**이며 [드래프트 모드](/docs/pages/building-your-application/configuring/draft-mode)로 대체됩니다.

<details>
  <summary>예제</summary>

- [WordPress 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-wordpress) ([데모](https://next-blog-wordpress.vercel.app))
- [DatoCMS 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-datocms) ([데모](https://next-blog-datocms.vercel.app/))
- [TakeShape 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-takeshape) ([데모](https://next-blog-takeshape.vercel.app/))
- [Sanity 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-sanity) ([데모](https://next-blog-sanity.vercel.app/))
- [Prismic 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-prismic) ([데모](https://next-blog-prismic.vercel.app/))
- [Contentful 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-contentful) ([데모](https://next-blog-contentful.vercel.app/))
- [Strapi 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-strapi) ([데모](https://next-blog-strapi.vercel.app/))
- [Prepr 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-prepr) ([데모](https://next-blog-prepr.vercel.app/))
- [Agility CMS 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-agilitycms) ([데모](https://next-blog-agilitycms.vercel.app/))
- [Cosmic 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-cosmic) ([데모](https://next-blog-cosmic.vercel.app/))
- [ButterCMS 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-buttercms) ([데모](https://next-blog-buttercms.vercel.app/))
- [Storyblok 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-storyblok) ([데모](https://next-blog-storyblok.vercel.app/))
- [GraphCMS 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-graphcms) ([데모](https://next-blog-graphcms.vercel.app/))
- [Kontent 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-kontent-ai) ([데모](https://next-blog-kontent.vercel.app//))
- [Umbraco Heartcore 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-umbraco-heartcore) ([데모](https://next-blog-umbraco-heartcore.vercel.app/))
- [Plasmic 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-plasmic) ([데모](https://nextjs-plasmic-example.vercel.app/))
- [Enterspeed 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-enterspeed) ([데모](https://next-blog-demo.enterspeed.com/))
- [Makeswift 예제](https://github.com/vercel/next.js/tree/canary/examples/cms-makeswift) ([데모](https://nextjs-makeswift-example.vercel.app/))

</details>

[Pages documentation](/docs/pages/building-your-application/routing/pages-and-layouts)과 [Data Fetching documentation](/docs/pages/building-your-application/data-fetching)에서, `getStaticProps`과 `getStaticPaths`를 사용하여 페이지를 빌드 타임에 미리 렌더링(**정적 생성**)하는 방법에 대해 다뤘습니다.

정적 생성은 페지가 headless CMS로부터 데이터를 가져올 때 유용합니다. 그러나 만약 headless CMS에 대한 드래프트를 작성하고 있고 그것을 페이지에서 **미리보기**하고 싶을 때 정적 생성은 이상적이지 않습니다. Next.js가 이러한 페이지를 빌드 시간 대신 **요청 시간**에 렌더링하고 게시된 내용 대신 초안 내용을 가져오기를 원할 겁니다. 그리고 Next.js가 이 특정한 경우에서만 정적 생성을 건너뛰기를 원할 것입니다.

Next.js는 이러한 문제를 해결하기 위해 **미리보기 모드**라는 기능을 갖고 있습니다. 이곳에서 이 기능의 사용 방법을 배웁니다.

## 스텝 1: 미리보기 API route를 생성하고 접근하기

> Next.js API Routes가 친숙하지 않다면 [API Routes 문서](/docs/pages/building-your-application/routing/api-routes)를 먼저 살펴보세요.

먼저, **미리보기 API route**를 생성하세요. 이것은 이름을 가질 수 있습니다. - 예 : `pages/api/preview.js` (TypeScript를 사용하고 있다면 `.ts`).

이 API route에서, 응답 객체에 대해 `setPreviewData`를 호출해야 합니다. `setPreviewData`의 매개변수는 객체여야만 하며, `getStaticProps`에 의해 사용될 수 있습니다(이에 대해 후술합니다). 이제부터 우리는 `{}`를 사용할 겁니다.

```js
export default function handler(req, res) {
  // ...
  res.setPreviewData({})
  // ...
}
```

`res.setPreviewData`는 미리보기 모드를 켜는 몇몇 쿠키를 브라우저에 설정합니다. 이러한 쿠키를 포함하는 모든 Next.js로의 요청은 미리보기 모드로 간주됩니다. 정적으로 생성된 페이지에 대한 동작이 변화합니다(이에 대해 후술합니다).

아래처럼 API route를 생성하고 브라우저에서 직접 접근하여 수동으로 테스트할 수 있습니다.

```js filename="pages/api/preview.js"
// 브라우저로 직접 테스트하기 위한 간단 예제
export default function handler(req, res) {
  res.setPreviewData({})
  res.end('Preview mode enabled')
}
```

브라우저의 개발자 도구를 열고 `/api/preview`에 가 보면, 이 요청에 대해 `__prerender_bypass`와 `__next_preview_data` 쿠키가 설정된 것을 알 수 있을 겁니다.

### Headless CMS로부터 안전하게 접근하기

실전에서는 headless CMS로부터 _안전하게_ 이 API route를 호출하고 싶을 겁니다. 구체적인 절차는 사용하고 있는 CMS에 따라 다르겠지만, 일반적으로 수행할 수 있는 몇몇 절차가 있습니다.

이 절차는 사용 중인 headless CMS가 **커스텀 미리보기 URL**의 설정을 지원한다고 가정합니다. 그렇지 않다면, 여전히 이 방법을 통해 미리 보기 URL을 보호할 수 있지만 수동으로 미리 보기 URL을 구성하고 접근해야 합니다.

**먼저**, 당신이 선택한 토큰 생성기를 통해 **비밀 토큰 문자열**을 생성해야 합니다. 이 비밀 키는 Next.js 앱과 headless CMS만 알 것입니다. 이 비밀은 CMS에 대한 접근 권한이 없는 사람들이 미리보기 URL에 접근하는 것을 막아줍니다.

**다음으로**, headless CMS가 커스텀 미리보기 URL의 설정을 지원한다면, 미리보기 URL대로 다음을 명시해야 합니다. 이는 미리보기 API route가 `pages/api/preview.js`에 위치하고 있다는 것을 가정합니다.

```bash filename="Terminal"
https://<your-site>/api/preview?secret=<token>&slug=<path>
```

- `<your-site>`는 배포 도메인이어야 합니다.
- `<token>`는 생성한 비밀 토큰으로 대체해야 합니다.
- `<path>`는 미리보기하고 싶은 페이지에 대한 경로여야 합니다. 만약 `/posts/foo`를 미리보기 하고 싶다면, `&slug=/posts/foo`를 사용해야 합니다.

headless CMS는 `<path`가 CMS의 데이터에 기반하여 동적으로 설정될 수 있도록 미리보기 URL에 변수를 포함하는 것을 허용할 수 있습니다. 이렇게 말이죠. `&slug=/posts/{entry.fields.slug}`

**마지막으로**, 미리보기 URL route에서 다음을 따르세요.
**Finally**, in the preview API route:

- 비밀 키가 일치하며 `slug` 매개변수가 존재하는지 확인하세요(만약 아니라면, 요청은 실패해야 합니다).
-
- `res.setPreviewData`를 호출하세요.
- 그런 다음 브라우저를 `slug`에 의해 지정된 경로로 리다이렉트하세요. (다음 예시는 [307 redirect](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307)를 사용합니다.)

```js
export default async (req, res) => {
  // 비밀 키와 다음 매개변수를 확인
  // 이 비밀 키는 이 API route와 CMS만 알고 있어야 함
  if (req.query.secret !== 'MY_SECRET_TOKEN' || !req.query.slug) {
    return res.status(401).json({ message: 'Invalid token' })
  }

  // 제공된 `slug`가 존재하는지 확인하기 위해 headless CMS 가져오기
  // getPostBySlug는 headless CMS로 데이터를 가져오는 데 필요한 로직을 구현하고 있을 겁니다.
  const post = await getPostBySlug(req.query.slug)

  // 해당 slug가 존재하지 않는다면 미리보기 모드의 활성화를 방지
  if (!post) {
    return res.status(401).json({ message: 'Invalid slug' })
  }

  // 쿠키를 설정하여 미리보기 모드를 활성화
  res.setPreviewData({})

  // 가져온 포스트의 경로로 리다이렉트
  // 오픈 리다이렉트 취약점으로 이어질 수 있기에 req.query.slug로 리다이렉트하지 않음
  res.redirect(post.slug)
}
```

성공한다면, 브라우저는 미리보기 모드 쿠키가 설정된 상태에서 미리보기 하기를 원하는 경로로 리다이렉트될 것입니다.

## 스텝 2: `getStaticProps` 업데이트하기

다음 단계는 미리보기 모드를 지원하기 위해 `getStaticProps`를 업데이트하는 것입니다.

미리보기 쿠키가 설정된 상태에서 `getStaticProps`를 가진 페이지를 요청한다면(`res.setPreviewData`를 통해), `getStaticProps`는 **요청 시간**에 호출됩니다(빌드 시간 대신).

게다가, `context` 객체와 함께 호출됩니다. `context` 객체는 다음과 같은 특징을 갖습니다.

- `context.preview`가 `true`일 것입니다.
- `context.previewData`가 `setPreviewData`에 사용되는 매개변수와 같을 것입니다.

```js
export async function getStaticProps(context) {
  // 미리보기 모드 쿠키가 설정된 상태에서 이 페이지를 요청하면:
  //
  // - context.preview는 true가 됩니다.
  // - context.previewData는 `setPreviewData`에 사용되는 매개변수와 같을 겁니다.
}
```

우리는 미리보기 API route에서 `res.setPreviewData({})`를 사용했으므로, `context.previewData`는 `{}`가 될 겁니다. 필요하다면 이를 이용해서 미리보기 API route로부터 `getStaticProps`로 세션 정보를 넘길 수 있습니다.

`getStaticPaths` 또한 사용하고 있다면, `context.params` 또한 이용할 수 있습니다.

### 미리보기 데이터 가져오기

`context.preview` 또는 `context.previewData`에 기반하여 다른 데이터를 가져오기 위해 `getStaticProps`를 업데이트할 수 있습니다.

예를 들어, headless CMS가 초안 포스트를 위해 다양한 API 엔드포인트를 가질 수 있습니다. 그렇다면, `context.preview`를 이용하여 API 엔드포인트 URL를 아래처럼 수정할 수 있습니다.

```js
export async function getStaticProps(context) {
  // context.preview가 true라면, 게시된 데이터 대신 초안 데이터를 요청하기 위해
  // API 엔드포인트에 "/preview"를 붙임.
  // 이는 사용 중인 headless CMS에 따라 달라질 수 있음
  const res = await fetch(`https://.../${context.preview ? 'preview' : ''}`)
  // ...
}
```

이제 다 됐습니다! headless CMS로부터 혹은 수동으로 미리보기 API route에 접근하면(`secret`과 `slug`를 통해), 미리보기 내용을 볼 수 있을 겁니다. 그리고 초안을 게시 없이 업데이트 하면 초안을 미리보기 할 수 있을 겁니다.

이것을 headless CMS에 미리보기 URL로 설정하거나 수동으로 접근하면, 미리보기를 볼 수 있을 겁니다.

```bash filename="Terminal"
https://<your-site>/api/preview?secret=<token>&slug=<path>
```

## 더 자세히

> **참고**: during rendering `next/router` exposes an `isPreview` flag, see the [router object docs](/docs/pages/api-reference/functions/use-router#router-object) for more info.

### Specify the Preview Mode duration

`setPreviewData` takes an optional second parameter which should be an options object. It accepts the following keys:

- `maxAge`: Specifies the number (in seconds) for the preview session to last for.
- `path`: Specifies the path the cookie should be applied under. Defaults to `/` enabling preview mode for all paths.

```js
setPreviewData(data, {
  maxAge: 60 * 60, // The preview mode cookies expire in 1 hour
  path: '/about', // The preview mode cookies apply to paths with /about
})
```

### Clear the Preview Mode cookies

By default, no expiration date is set for Preview Mode cookies, so the preview session ends when the browser is closed.

To clear the Preview Mode cookies manually, create an API route that calls `clearPreviewData()`:

```js filename="pages/api/clear-preview-mode-cookies.js"
export default function handler(req, res) {
  res.clearPreviewData({})
}
```

Then, send a request to `/api/clear-preview-mode-cookies` to invoke the API Route. If calling this route using [`next/link`](/docs/pages/api-reference/components/link), you must pass `prefetch={false}` to prevent calling `clearPreviewData` during link prefetching.

If a path was specified in the `setPreviewData` call, you must pass the same path to `clearPreviewData`:

```js filename="pages/api/clear-preview-mode-cookies.js"
export default function handler(req, res) {
  const { path } = req.query

  res.clearPreviewData({ path })
}
```

### `previewData` size limits

You can pass an object to `setPreviewData` and have it be available in `getStaticProps`. However, because the data will be stored in a cookie, there’s a size limitation. Currently, preview data is limited to 2KB.

### Works with `getServerSideProps`

The preview mode works on `getServerSideProps` as well. It will also be available on the `context` object containing `preview` and `previewData`.

### Works with API Routes

API Routes will have access to `preview` and `previewData` under the request object. For example:

```js
export default function myApiRoute(req, res) {
  const isPreview = req.preview
  const previewData = req.previewData
  // ...
}
```

### Unique per `next build`

Both the bypass cookie value and the private key for encrypting the `previewData` change when `next build` is completed.
This ensures that the bypass cookie can’t be guessed.

> **Good to know**: To test Preview Mode locally over HTTP your browser will need to allow third-party cookies and local storage access.
