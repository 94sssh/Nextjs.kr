---
title: TypeScript
description: Next.js provides a TypeScript-first development experience for building your React application.
---

Next.js는 React 애플리케이션을 구축하기 위한 TypeScript 우선 개발 환경을 제공합니다.

필요한 패키지를 자동으로 설치하고 적절한 설정을 구성하기 위한 TypeScript 지원이 내장되어 있습니다.

<AppOnly>
또한 에디터용 TypeScript 플러그인도 제공됩니다.

> **🎥 Watch:** 내장된 TypeScript 플러그인에 대해 알아보기 → [YouTube (3 minutes)](https://www.youtube.com/watch?v=pqMqn9fKEf8)

</AppOnly>

## 새로운 프로젝트

create-next-app은 이제 기본적으로 TypeScript이 함께 제공됩니다.

```bash filename="Terminal"
npx create-next-app@latest
```

## 기존 프로젝트

파일 이름을 `.ts` / `.tsx` 로 변경하여 프로젝트에 TypeScript를 추가합니다. `next dev` 와 `next build`를 실행하여 필요한 dependencies을 자동으로 설치하고 권장 구성 옵션이 포함된 `tsconfig.json` 파일을 추가합니다.

<AppOnly>

## 타입스크립트 플러그인

Next.js에는 사용자 지정 TypeScript 플러그인 및 type 검사기가 포함되어 있어 VSCode 및 기타 코드 편집기에서 고급 type 검사 및 자동 완성을 위해 사용할 수 있습니다.

TypeScript 파일이 열려 있는 상태에서 `next dev`를 처음 실행하면 플러그인을 활성화하라는 메시지가 표시됩니다.

<Image
  alt="TypeScript Prompt"
  srcLight="/docs/light/typescript-prompt.png"
  srcDark="/docs/dark/typescript-prompt.png"
  width="1600"
  height="403"
/>

프롬프트를 누락했다면 플러그인을 수동으로 활성화할 수 있습니다:

1. Opening the command palette (`Ctrl/⌘` + `Shift` + `P`)
2. Searching for "TypeScript: Select TypeScript Version"
3. Selecting "Use Workspace Version"

<Image
  alt="TypeScript Command Palette"
  srcLight="/docs/light/typescript-command-palette.png"
  srcDark="/docs/dark/typescript-command-palette.png"
  width="1600"
  height="637"
/>

이제 파일을 편집할 때 사용자 정의 플러그인이 활성화됩니다. `next build`를 실행할 때 사용자 정의 type 검사기가 사용됩니다. 또한 이 프로세스를 자동화하기 위해 VSCode 설정 파일을 자동으로 생성합니다.

### 플러그인 기능

TypeScript 플러그인이 도움이 될 수 있습니다:

- [세그먼트 구성 옵션](/docs/app/api-reference/file-conventions/route-segment-config)에 대해 잘못된 값을 전달하면 경고가 표시됩니다.
- 사용 가능한 옵션 및 상황에 맞는 문서 표시
- `use client` 지시어가 올바르게 사용되었는지 확인합니다.
- 클라이언트 훅(예: `useState`)이 클라이언트 컴포넌트에서만 사용되도록 합니다. 

> **알아두면 유용한 정보**: 앞으로 더 많은 기능이 추가될 예정입니다.

</AppOnly>

## 최소 TypeScript 버전

[import names 의 type 수정자](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#type-on-import-names) 및 [성능 개선](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#real-path-sync-native)과 같은 syntax기능을 사용하려면 TypeScript v4.5.2 이상을 사용할 것을 적극 권장합니다.


<AppOnly>

## 정적 유형 링크

Next.js는 `next/link`를 사용할 때 오타 및 기타 오류를 방지하기 위해 링크를 정적으로 입력할 수 있어 페이지 간 탐색 시 유형 안전성이 향상됩니다.

이 기능을 사용하려면 `experimental.typedRoutes`를 활성화해야 하며 프로젝트에서 TypeScript를 사용해야 합니다.

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
}

module.exports = nextConfig
```

Next.js는 애플리케이션의 모든 기존 경로에 대한 정보를 포함하는 링크 정의를 `.next/types`에 생성하며, 이 링크 정의는 TypeScript가 편집기에서 잘못된 링크에 대한 피드백을 제공하는 데 사용할 수 있습니다.

현재 실험적으로 지원되는 것은 동적 세그먼트를 포함한 모든 문자열 리터럴입니다. 리터럴이 아닌 문자열의 경우, 현재 `href`를 `as Route`로 수동으로 캐스팅해야 합니다:

```tsx
import type { Route } from 'next';
import Link from 'next/link'

// No TypeScript errors if href is a valid route
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// TypeScript errors if href is not a valid route
<Link href="/aboot" />
```

`next/link`를 감싸는 사용자 정의 컴포넌트에서 `href`를 사용하려면 제네릭을 사용합니다:

```tsx
import type { Route } from 'next';
import Link from 'next/link';

function Card<T extends string>({ href }: { href: Route<T> | URL })
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  );
}
```

> **어떻게 작동하나요?**
>
> `next dev` 또는 `next build`를 실행할 때 Next.js는 애플리케이션의 모든 기존 경로(`링크`의 `href` 유형으로 유효한 모든 경로)에 대한 정보를 포함하는 숨겨진 `.d.ts` 파일을 `.next` 내부에 생성합니다. 이 `.d.ts` 파일은 `tsconfig.json`에 포함되며 TypeScript 컴파일러는 이 `.d.ts`를 검사하여 유효하지 않은 링크에 대한 피드백을 에디터에 제공합니다.

## End-to-End Type Safety

Next.js 13 has **enhanced type safety**. This includes:

1. **No serialization of data between fetching function and page**: You can `fetch` directly in components, layouts, and pages on the server. This data _does not_ need to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, since `app` uses Server Components by default, we can use values like `Date`, `Map`, `Set`, and more without any extra steps. Previously, you needed to manually type the boundary between server and client with Next.js-specific types.
2. **Streamlined data flow between components**: With the removal of `_app` in favor of root layouts, it is now easier to visualize the data flow between components and pages. Previous, data flowing between individual `pages` and `_app` were difficult to type and could introduce confusing bugs. With [colocated data fetching](/docs/app/building-your-application/data-fetching/fetching) in Next.js 13, this is no longer an issue.

[Data Fetching in Next.js](/docs/app/building-your-application/data-fetching/fetching) now provides as close to end-to-end type safety as possible without being prescriptive about your database or content provider selection.

We're able to type the response data as you would expect with normal TypeScript. For example:

```tsx filename="app/page.tsx"
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // The return value is *not* serialized
  // You can return Date, Map, Set, etc.
  return res.json()
}

export default async function Page() {
  const name = await getData()

  return '...'
}
```

For _complete_ end-to-end type safety, this also requires your database or content provider to support TypeScript. This could be through using an [ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping) or type-safe query builder.

## Async Server Component TypeScript Error

To use an `async` Server Component with TypeScript, ensure you are using TypeScript `5.1.3` or higher and `@types/react` `18.2.8` or higher.

If you are using an older version of TypeScript, you may see a `'Promise<Element>' is not a valid JSX element` type error. Updating to the latest version of TypeScript and `@types/react` should resolve this issue.

## Passing Data Between Server & Client Components

When passing data between a Server and Client Component through props, the data is still serialized (converted to a string) for use in the browser. However, it does not need a special type. It’s typed the same as passing any other props between components.

Further, there is less code to be serialized, as un-rendered data does not cross between the server and client (it remains on the server). This is only now possible through support for Server Components.

</AppOnly>

<PagesOnly>

## Static Generation and Server-side Rendering

For [`getStaticProps`](/docs/pages/api-reference/functions/get-static-props), [`getStaticPaths`](/docs/pages/api-reference/functions/get-static-paths), and [`getServerSideProps`](/docs/pages/api-reference/functions/get-server-side-props), you can use the `GetStaticProps`, `GetStaticPaths`, and `GetServerSideProps` types respectively:

```tsx filename="pages/blog/[slug].tsx"
import { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'

export const getStaticProps: GetStaticProps = async (context) => {
  // ...
}

export const getStaticPaths: GetStaticPaths = async () => {
  // ...
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  // ...
}
```

## API Routes

The following is an example of how to use the built-in types for API routes:

```ts
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ name: 'John Doe' })
}
```

You can also type the response data:

```ts
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'John Doe' })
}
```

## Custom `App`

If you have a [custom `App`](/docs/pages/building-your-application/routing/custom-app), you can use the built-in type `AppProps` and change file name to `./pages/_app.tsx` like so:

```ts
import type { AppProps } from 'next/app'

export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}
```

</PagesOnly>

## Path aliases and baseUrl

Next.js automatically supports the `tsconfig.json` `"paths"` and `"baseUrl"` options.

You can learn more about this feature on the [Module Path aliases documentation](/docs/pages/building-your-application/configuring/absolute-imports-and-module-aliases).

## Type checking next.config.js

The `next.config.js` file must be a JavaScript file as it does not get parsed by Babel or TypeScript, however you can add some type checking in your IDE using JSDoc as below:

```js
// @ts-check

/**
 * @type {import('next').NextConfig}
 **/
const nextConfig = {
  /* config options here */
}

module.exports = nextConfig
```

## Incremental type checking

Since `v10.2.1` Next.js supports [incremental type checking](https://www.typescriptlang.org/tsconfig#incremental) when enabled in your `tsconfig.json`, this can help speed up type checking in larger applications.

## Ignoring TypeScript Errors

Next.js fails your **production build** (`next build`) when TypeScript errors are present in your project.

If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.

If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.

Open `next.config.js` and enable the `ignoreBuildErrors` option in the `typescript` config:

```js filename="next.config.js"
module.exports = {
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}
```

## Version Changes

| Version   | Changes                                                                                                                              |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `v13.2.0` | Statically typed links are available in beta.                                                                                        |
| `v12.0.0` | [SWC](/docs/architecture/nextjs-compiler) is now used by default to compile TypeScript and TSX for faster builds.                    |
| `v10.2.1` | [Incremental type checking](https://www.typescriptlang.org/tsconfig#incremental) support added when enabled in your `tsconfig.json`. |
